package lib

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
)

/*
   alpmbuild â€” a tool to build arch packages from RPM specfiles

   Copyright (C) 2020  Carson Black

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

// These directives aren't sections, but should cause the stages
// to switch to NoStage
var otherDirectives []string = []string{
	"%package",
}

type Stage int

const (
	NoStage Stage = iota + 1
	PrepareStage
	BuildStage
	InstallStage
	FileStage

	IfTrueStage
	IfFalseStage
)

type PackageContext struct {
	// Single-value fields with relatively standard behaviour.
	Name    string `macro:"name" key:"name:" pkginfo:"pkgname"`
	Summary string `macro:"summary" key:"summary:" pkginfo:"pkgdesc"`
	License string `macro:"license" key:"license:" pkginfo:"pkglicense"`
	URL     string `macro:"url" key:"url:" pkginfo:"url"`

	// Array fields with relatively standard behaviour.
	Requires      []string `keyArray:"requires:" pkginfo:"depend"`
	BuildRequires []string `keyArray:"buildrequires:" pkginfo:"makedepend"`

	// Nonstandard single-value fields
	Version string `macro:"version" key:"version:"`
	Release string `macro:"release" key:"release:"`

	// Nonstandard array fields
	Sources []string
	Patches []string
	Files   []string

	// Command fields
	Commands struct {
		Prepare []string
		Build   []string
		Install []string
	}

	// Other fields
	IsSubpackage  bool
	parentPackage *PackageContext
	Subpackages   map[string]PackageContext
}

func (pkg PackageContext) GeneratePackageInfo() {
	home, err := os.UserHomeDir()
	if err != nil {
		panic(fmt.Sprintf("Failed to generate pkginfo:\n%s", err.Error()))
	}
	pkgdir := ""
	if !pkg.IsSubpackage {
		pkgdir = filepath.Join(home, "alpmbuild/package")
	} else {
		pkgdir = filepath.Join(home, "alpmbuild/subpackages", pkg.Name)
	}
	os.Chdir(pkgdir)

	packageInfo := "# Generated by alpmbuild"

	fields := reflect.TypeOf(pkg)
	num := fields.NumField()

	for i := 0; i < num; i++ {
		field := fields.Field(i)

		if packageInfoKey := field.Tag.Get("pkginfo"); packageInfoKey != "" {
			// These are the single-value keys, such as Name, Version, Release, and Summary
			if field.Tag.Get("key") != "" {
				// We assert that packageContext only has string fields here.
				// If it doesn't, our code will break.
				key := reflect.ValueOf(&pkg).Elem().FieldByName(field.Name)
				if key.IsValid() {
					if key.String() != "" {
						packageInfo = fmt.Sprintf("%s\n%s = %s", packageInfo, packageInfoKey, key.String())
					}
				}
			}
			// These are the multi-value keys, such as Requires and BuildRequires
			if field.Tag.Get("keyArray") != "" {
				// We assume that packageContext only has string array fields here.
				// If it doesn't, our code will break.
				key := reflect.ValueOf(&pkg).Elem().FieldByName(field.Name)
				if key.IsValid() {
					keyInterface := key.Interface()
					keyArray := keyInterface.([]string)

					for _, item := range keyArray {
						packageInfo = fmt.Sprintf("%s\n%s = %s", packageInfo, packageInfoKey, item)
					}
				}
			}
		}
	}

	{ // This turns version and release into a single key
		if pkg.IsSubpackage {
			packageInfo = fmt.Sprintf(
				"%s\npkgver = %s-%s",
				packageInfo,
				defaultString(pkg.Version, pkg.parentPackage.Version),
				defaultString(pkg.Release, pkg.parentPackage.Release),
			)
		} else {
			packageInfo = fmt.Sprintf("%s\npkgver = %s-%s", packageInfo, pkg.Version, pkg.Release)
		}
	}

	err = ioutil.WriteFile(filepath.Join(pkgdir, ".PKGINFO"), []byte(packageInfo), 0644)
	if err != nil {
		panic(fmt.Sprintf("Failed to generate pkginfo:\n%s", err.Error()))
	}
}

func (pkg PackageContext) GenerateMTree() {
	home, err := os.UserHomeDir()
	if err != nil {
		panic(fmt.Sprintf("Failed to generate mtree:\n%s", err.Error()))
	}
	if !pkg.IsSubpackage {
		os.Chdir(filepath.Join(home, "alpmbuild/package"))
	} else {
		os.Chdir(filepath.Join(home, "alpmbuild/subpackages", pkg.Name))
	}

	cmd := exec.Command("sh", "-c", `LANG=C bsdtar -c -f - --format=mtree \
	--options='!all,use-set,type,uid,gid,mode,time,size,md5,sha256,link' \
	--null --exclude .MTREE * | gzip -c -f -n > .MTREE`)
	output, err := cmd.CombinedOutput()
	if err != nil {
		panic(fmt.Sprintf("Failed to generate mtree:\n%s", string(output)))
	}
}

func setupDirectories() error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	for _, dir := range []string{"alpmbuild/buildroot", "alpmbuild/package", "alpmbuild/sources", "alpmbuild/packages", "alpmbuild/subpackages"} {
		err = os.MkdirAll(filepath.Join(home, dir), os.ModePerm)
		if err != nil {
			return err
		}
	}

	return nil
}

func (pkg PackageContext) setupSources() error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	handleSource := func(url string) error {
		if isValidUrl(url) {
			err := downloadFile(filepath.Join(home, "alpmbuild/buildroot", path.Base(url)), url)
			if err != nil {
				return err
			}
		} else {
			_, err := copyFile(filepath.Join(home, "alpmbuild/sources", url), filepath.Join(home, "alpmbuild/buildroot", url))
			if err != nil {
				return err
			}
		}
		return nil
	}

	for _, source := range pkg.Sources {
		err := handleSource(source)
		if err != nil {
			return err
		}
	}
	for _, patch := range pkg.Patches {
		err := handleSource(patch)
		if err != nil {
			return err
		}
	}

	return nil
}

func (pkg PackageContext) CompressPackage() {
	home, err := os.UserHomeDir()
	if err != nil {
		panic("Could not get user's home directory.")
	}
	packagesDir := filepath.Join(home, "alpmbuild/packages")
	if !pkg.IsSubpackage {
		os.Chdir(filepath.Join(home, "alpmbuild/package"))
	} else {
		os.Chdir(filepath.Join(home, "alpmbuild/subpackages", pkg.Name))
	}

	cmd := exec.Command("sh", "-c", "tar -czvf"+packagesDir+"/"+pkg.Name+".pkg.tar.gz * .PKGINFO .MTREE")
	output, err := cmd.CombinedOutput()
	if err != nil {
		panic(fmt.Sprintf("Creating tarball failed:\n%s", string(output)))
	}
}

func mapEnv(in string) string {
	home, err := os.UserHomeDir()
	if err != nil {
		panic("Could not get user's home directory.")
	}

	switch in {
	case "PREFIX":
		return filepath.Join(home, "alpmbuild/package")
	}

	return ""
}

func (pkg PackageContext) VerifyFiles() {
	home, err := os.UserHomeDir()
	if err != nil {
		panic("Could not get user's home directory.")
	}

	pathToWalk := ""

	if !pkg.IsSubpackage {
		pathToWalk = filepath.Join(home, "alpmbuild/package")
	} else {
		pathToWalk = filepath.Join(home, "alpmbuild/subpackages", pkg.Name)
	}

	err = filepath.Walk(
		pathToWalk,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				panic("Could not verify files: " + err.Error())
			}
			if file, err := os.Stat(path); err != nil || file.Mode().IsDir() {
				return nil
			}
			truncPath := strings.TrimPrefix(
				path,
				pathToWalk,
			)
			if truncPath == "" || truncPath == "/.MTREE" || truncPath == "/.PKGINFO" {
				return nil
			}
			hasMatch := false
			for _, listedFile := range pkg.Files {
				regexString := strings.ReplaceAll(listedFile, "/", "\\/")
				regexString = strings.ReplaceAll(listedFile, ".", "\\.")
				regexString = strings.ReplaceAll(regexString, "*", ".*")
				regex, err := regexp.Compile(regexString)
				if err != nil {
					panic("Malformed files listing: " + err.Error())
				}
				if regex.MatchString(truncPath) {
					hasMatch = true
				}
			}
			for _, subpackage := range pkg.Subpackages {
				for _, listedFile := range subpackage.Files {
					regexString := strings.ReplaceAll(listedFile, "/", "\\/")
					regexString = strings.ReplaceAll(listedFile, ".", "\\.")
					regexString = strings.ReplaceAll(regexString, "*", ".*")
					regex, err := regexp.Compile(regexString)
					if err != nil {
						panic("Malformed files listing: " + err.Error())
					}
					if regex.MatchString(truncPath) {
						hasMatch = true
					}
				}
			}
			if !hasMatch {
				panic("File not listed:\t" + truncPath)
			}
			return nil
		},
	)

	if err != nil {
		panic("Could not verify files: " + err.Error())
	}
}

func (pkg PackageContext) TakeFilesFromParent() {
	home, err := os.UserHomeDir()
	if err != nil {
		panic("Could not get user's home directory.")
	}
	path := filepath.Join(home, "alpmbuild/subpackages", pkg.Name)
	os.MkdirAll(path, os.ModePerm)

	for _, file := range pkg.Files {
		globPath := filepath.Join(home, "alpmbuild/package", file)
		files, err := filepath.Glob(globPath)
		if err != nil {
			panic("Bad globbing: " + err.Error())
		}
		for _, fileToCopy := range files {
			fromPackageRootPath := strings.TrimPrefix(fileToCopy, filepath.Join(home, "alpmbuild/package"))
			dirName, _ := filepath.Split(fromPackageRootPath)
			os.MkdirAll(filepath.Join(path, dirName), os.ModePerm)
			err = os.Rename(fileToCopy, filepath.Join(path, fromPackageRootPath))
			if err != nil {
				panic("Failed to take file from parent package: " + err.Error())
			}
		}
	}
}

func (pkg PackageContext) BuildPackage() {
	err := setupDirectories()
	if err != nil {
		panic(fmt.Sprintf("Error setting up directories:\n\t%s", err.Error()))
	}
	err = pkg.setupSources()
	if err != nil {
		panic(fmt.Sprintf("Error setting up sources:\n\t%s", err.Error()))
	}

	home, err := os.UserHomeDir()
	if err != nil {
		panic("Could not get user's home directory.")
	}

	os.Chdir(filepath.Join(home, "alpmbuild/buildroot"))

	safeRun := func(command string) {
		args := strings.Fields(os.Expand(command, mapEnv))

		if args[0] == "cd" {
			wd, err := os.Getwd()
			if err != nil {
				panic(fmt.Sprintf("Failed to get working directory:\n\t%s", err.Error()))
			}
			os.Chdir(path.Join(wd, args[1]))
			return
		}

		cmd := exec.Command("fakeroot", args...)

		output, err := cmd.CombinedOutput()
		if err != nil {
			panic(fmt.Sprintf("Command failed:\n\t%s\n\n%s", strings.Join(args, " "), string(output)))
		}
	}

	// Prepare commands.
	for _, command := range pkg.Commands.Prepare {
		safeRun(command)
	}
	for _, command := range pkg.Commands.Build {
		safeRun(command)
	}
	for _, command := range pkg.Commands.Install {
		safeRun(command)
	}

	for _, subpackage := range pkg.Subpackages {
		subpackage.TakeFilesFromParent()
		subpackage.GeneratePackageInfo()
		subpackage.GenerateMTree()
		subpackage.CompressPackage()
		subpackage.VerifyFiles()
	}

	pkg.GeneratePackageInfo()
	pkg.GenerateMTree()
	pkg.CompressPackage()
	if *checkFiles {
		pkg.VerifyFiles()
	}
}
